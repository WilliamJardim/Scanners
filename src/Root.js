/**
* WilliamJardim/Scanners © 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. 
* To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.scanner){ window.scanner = {} };

scanner.Base = function(config){
    const context = {};
    context._config = config;
    context.objectName = 'Base';
    context.extendedFrom = 'Base';
    context.namespace = 'window.scanner';
    context.path = 'scanner.Base';
    context.autoGeneratedGetters = [];
    context.autoGeneratedSetters = [];
    context._translations = config.translations;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    context.copyArgs = function(config){
        //Copia os argumentos
        let configKeys = Object.keys(config);
        for( let i = 0 ; i < configKeys.length ; i++){
            context[ configKeys[i] ] = config[ configKeys[i] ];
        }
    }

    context.copyArgsSeNaoExistir = function(config, aplicarBind=true){
        //Copia os argumentos
        let configKeys = Object.keys(config);

        for( let i = 0 ; i < configKeys.length ; i++){

            if( context[ configKeys[i] ] == undefined )
            {
                context[ configKeys[i] ] = config[ configKeys[i] ];
                if(aplicarBind == true && context[ configKeys[i] ].bind != undefined){
                    context[ configKeys[i] ].bind(context);
                }
            }

        }
    }

    context._doDefaultBaseAfterCreate = function(){
        context.createGettersFromOriginalProperties();
        context.createSettersFromOriginalProperties();
    }

    context.createGettersFromOriginalProperties = function(){
        //Getters
        Object.keys( context ).forEach( function(attrib){
            const nameOfGetter = `get${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfGetter] ){
                context[nameOfGetter] = function(){
                    return context[attrib];
                }
                context.autoGeneratedGetters.push(nameOfGetter);
            }
        });
    }

    context.createSettersFromOriginalProperties = function(){
        //Setters
        Object.keys( context ).forEach( function(attrib){
            const nameOfSetter = `set${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfSetter] ){
                context[nameOfSetter] = function(valueToDefine){
                    context[attrib] = valueToDefine; 
                }
                context.autoGeneratedSetters.push(nameOfSetter);
            }
        });
    }

    //Métodos responsavel por fazer as traduções dos métodos
    context.translateMethods = function(translations) {
        let translationsKeys;

        //Traduz os métodos
        translationsKeys = Object.keys(translations.translatedMethods);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedMethods[nomeMetodoTraduzido];

           //Aplica a tradução
           if(typeof context[nomeOriginal] === 'function'){
               context[nomeMetodoTraduzido] = context[nomeOriginal].bind(context);
           }
        }
    }

    //Métodos responsavel por fazer as traduções dos atributos
    context.translateAttributes = function(translations) {
        let translationsKeys;

        //Traduz os atributos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           //Aplica a tradução no atributo
           if(context[nomeOriginal] != undefined && typeof context[nomeOriginal] != 'function' && !context[nomeMetodoTraduzido] ){
              context[nomeMetodoTraduzido] = context[nomeOriginal];
           }
        }
    }

    //Parecido com a função translateAttributes, porém ele faz essa tradução e retorna um objeto com as traduções aplicadas
    //No caso o translationsDicionario pode ser um objeto ja pronto que só precisa ser traduzido
    //Isso vai ser usado na inicialização de algumas classes como Vectorization.Matrix e Vectorization.Vector
    context.translateAttributes_andReturn = function(propioDicionario, translations){
        let translationsKeys;
        let novoObjeto = {... propioDicionario};

        //Traduz os atributos
        translationsKeys = Object.keys(propioDicionario);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           if( nomeOriginal != undefined && !propioDicionario[nomeOriginal] ){
               novoObjeto[nomeOriginal] = propioDicionario[nomeMetodoTraduzido];
           }
        }

        return novoObjeto;
    }

    //Para não ter problemas com atributos desatualizados
    context.atualizarAtributosTraduzidos = function(translations=context._internal_translations){
        let translationsKeys;

        //Pegar os atributos traduzidos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
            const nomeMetodoTraduzido = translationsKeys[i];
            const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

            if( nomeOriginal != undefined && 
                typeof context[nomeMetodoTraduzido] != 'function' && 
                typeof context[nomeOriginal] != 'function' &&
                context[nomeOriginal] != undefined &&
                context[nomeMetodoTraduzido] != undefined
            ){
                context[nomeMetodoTraduzido] = context[nomeOriginal];
            }
        }
    }

    //Start class
    context.copyArgs(config);
    context._doDefaultBaseAfterCreate();

    context.applyTranslations = function(translationFunction=null){
        //Se existir uma tradução para a classe
        if(context._translations && typeof context._translations === 'function'){
            context._internal_translations = translationFunction || context._translations();
            context.translateMethods( context._internal_translations );
            context.translateAttributes( context._internal_translations );
        }
    }

    context.applyTranslations(null);

    context.getTodasConfiguracoesAplicadas = function(){
        let todasConfiguracoesClassConfig = {};
        let keysConfiguracoesClassConfig = [... Object.keys(context)];

        for( let i = 0 ; i < keysConfiguracoesClassConfig.length ; i++ )
        {
            let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
                valorConfiguracaoClassConfig = context[nomeConfiguracaoClassConfig];
            
            todasConfiguracoesClassConfig[nomeConfiguracaoClassConfig] = valorConfiguracaoClassConfig;
        }

        return { 
                  configuracoesUsadas: todasConfiguracoesClassConfig,
                  quantidadeDentro: keysConfiguracoesClassConfig.length
               };
    }

    context.herdarFuncoes = function(referenciaObjeto){
        const templateObjetoCriado = referenciaObjeto();
        const contextObjetoCriado = templateObjetoCriado;
        
        //Aplica dentro deste objeto do Vectorization
        context.copyArgsSeNaoExistir(contextObjetoCriado); 
    }

    return context;
}

//Métodos estáticos

/**
* Gera um ID para ser usado em alguma coisa
* @returns {Number}
*/
scanner.enumerarInstancia = function(){
    if( scanner._instancias == undefined )
    { 
        scanner._instancias = 0;
    }

    scanner._instancias++;
    return scanner._instancias;
}

scanner.utils = {
    colocarDelay: async function(tempo) {
        return new Promise(function(resolve){
            setTimeout(resolve, tempo)
        });
    },

    aguardarCarregamentos: async function(imagens, callback){
        let terminadas = 0;

        while(true){
            for( let i = 0 ; i < imagens.length ; i++ )
            {
                if( imagens[i].src != '' && imagens[i].complete == true || imagens[i].chamouOnload != undefined )
                {
                    terminadas++;
                }

                imagens[i].onload = function(){
                    this.chamouOnload = true;
                }
            }

            if( terminadas >= imagens.length ){
                await callback(imagens);
                break;
            }
        }
    },

    escutar: async function(contextoMonitorar, callbackMonitoramento, callbackFinal=null){
      
        setTimeout( function(){

            let contextoEscuta = {
                rodando: true,

                finalizar: function(){
                    this.rodando = false;
                }
            };

            while(contextoEscuta.rodando == true)
            {
                //Fica chamando a função de monitoramento
                const funcao = callbackMonitoramento.bind(contextoEscuta)(contextoMonitorar, contextoEscuta);
            }

            if( contextoEscuta.rodando == false ){
                if( callbackFinal != undefined && callbackFinal != null ){ callbackFinal.bind(contextoEscuta)() };
            }

        }, 10 );
    },

    /**
    * Cria uma imagem usando um base64
    * @param {String} dataUrl 
    * @returns {Image}
    */
    criarImagem: function(dataUrl){

        return new Promise(function(resolve, reject){
            const imagem = document.createElement('img');
            const instanciaId = `imagem${ scanner.enumerarInstancia() }`;
            imagem.crossOrigin = "anonymous";
            imagem.setAttribute("crossOrigin", "");
            imagem.setAttribute("id", instanciaId);

            imagem.onload = function(){
                resolve(this); 
            }

            setTimeout(function(){
                imagem.src = dataUrl;
            }, 100);

        });

    },

    cortarImagem: async function(imagemOriginal, novoX, novoY, novaLargura, novaAltura) {

        return new Promise(async function(resolve){
            //Cria um novo canvas
            const canvas = scanner.pagina.criarElementoHtml('canvas');

            canvas.aplicarAtributos({
                width: novaLargura,
                height: novaAltura
            })
             
            const ctx = canvas.getElemento()
                              .getContext('2d');

            ctx.drawImage(imagemOriginal, novoX, novoY, novaAltura, novaAltura, 0, 0, novaAltura, novaAltura); 

            const imagemCortada = await scanner.utils.criarImagem( 
                                                                   canvas.getElemento()
                                                                         .toDataURL() 
                                                                 );
           	
            resolve(imagemCortada);        
        });
        
    },

    extrairPixels: async function(imagem){
        //Cria um novo canvas
        const canvas = scanner.pagina.criarElementoHtml('canvas');

        canvas.aplicarAtributos({
            width: imagem.width,
            height: imagem.height
        })

        document.body.appendChild(canvas.getElemento());

        const ctx = canvas.getElemento()
                          .getContext('2d');

        ctx.drawImage(imagem, 0, 0, canvas.getElemento().width, canvas.getElemento().height);

        let pixelData = ctx.getImageData(0, 0, canvas.getElemento().width, canvas.getElemento().height);
        document.body.removeChild(canvas.getElemento());

        const resposta = {
            data: pixelData.data,
        };

        return resposta;
    },

    /**
    * @param {Image} imagem1
    * @param {Image} imagem2
    */
    semelhancaImagems: async function(imagem1, imagem2, porcentagemAceito){
        const A = imagem1 instanceof Array ? imagem1 : (await this.extrairPixels(imagem1)).data;
        const B = imagem2 instanceof Array ? imagem2 : (await this.extrairPixels(imagem2)).data;
        let equal = 0;
        let different = 0;
        let ignored = 0;

        for( let i = 0 ; i < A.length ; i++ ){
            if(A[i] == B[i]){
                equal++

            } else {
                different++;
            }
        }

        return { 
                 equal: equal, 
                 different: different,
                 bateu: (equal*100) / (A.length - ignored) >= porcentagemAceito
               };
    },

    /**
    * Tenta extrair um rosto na imagem(usando um método muito simples de corte)
    * @param {Image} foto 
    * @returns {Image}
    */
    extrairRostoNaImagem: async function(foto){
        const contexto = this;
        //Corta a imagem na area onde acho que é o rosto(uma area qualquer que eu defini)
        return [ (await contexto.cortarImagem(foto, 80, 80, 120, 120)) ];
    },

    /**
    * Deixa a imagem em tons de cinza
    * @param {Image} foto 
    * @returns {Image}
    */
    tonsDeCinza: async function(foto) {
        return new Promise( async function(resolve) {
            //Cria um novo canvas
            const canvas = scanner.pagina.criarElementoHtml('canvas');

            canvas.aplicarAtributos({
                width: foto.width,
                height: foto.height
            })

            const ctx = canvas.getElemento()
                              .getContext('2d');

            ctx.filter = 'grayscale(1)';
            ctx.drawImage(foto, 0, 0, canvas.width, canvas.height);

            const dadosb64Imagem = canvas.getElemento()
                                         .toDataURL();

            const fotoProcessada = await scanner.utils.criarImagem( dadosb64Imagem );

            resolve(fotoProcessada);
        
        });
    },

    redimensionarFoto: function(foto, novaLargura, novaAltura){
        return new Promise(async function(resolve){
            //Cria um novo canvas
            const canvas = scanner.pagina.criarElementoHtml('canvas');

            canvas.aplicarAtributos({
                width: 0,
                height: 0
            })

            const ctx = canvas.getElemento()
                            .getContext('2d');

            canvas.width = novaLargura;
            canvas.height = novaAltura;

            ctx.drawImage(foto, 0,0, novaLargura, novaAltura);

            const dadosb64Imagem = canvas.getElemento()
                                        .toDataURL();
            
            const fotoProcessada = await scanner.utils.criarImagem( dadosb64Imagem );

            resolve(fotoProcessada);
        });
    },

    //Procura se uma imagem aparece numa foto, e retorna os dados sobre ela
    findImageInImage: async function(template, target, porcentoAceito=28){
        const contexto = this;

        return new Promise( async function(resolve) {

            try{
                const facesTemplate = await contexto.extrairRostoNaImagem(template);
                const facesTarget   = await contexto.extrairRostoNaImagem(target);

                let templateFace = facesTemplate[facesTemplate.length-1];
                let targetFace = facesTarget[facesTarget.length-1];

                let templateFace_BRILHO_IGUAL = templateFace;
                let targetFace_BRILHO_IGUAL = targetFace;

                //Talves tentar normalizar o brilho

                async function int_getAnalise(tempFace, targFace){
                    const templateFaceGray = await contexto.tonsDeCinza(tempFace);
                    const targetFaceGray = await contexto.tonsDeCinza(targFace);

                    /*IGUALA A LAGURA E A ALTURA*/
                    const resizedTargetFace = await contexto.redimensionarFoto( targetFaceGray, templateFaceGray.width, templateFaceGray.height );
                    
                    //Aplica o algoritmo de analise escolhido
                    const analise = contexto.semelhancaImagems(await contexto.extrairPixels(templateFaceGray).data, await contexto.extrairPixels(resizedTargetFace).data, porcentoAceito);

                    //Retorna o resultado
                    return analise;
                }

                let analiseAtual = await int_getAnalise(templateFace_BRILHO_IGUAL, targetFace_BRILHO_IGUAL);
                
                let porcentosHIP = [];
                let porcentosHIP_PRETOBRANCO = [];
                porcentosHIP.push(analiseAtual.porcentoIgual);

                //Pega a possibilidade dessas testadas que os pixels sao mais iguais, mais bateram
                analiseAtual.porcentoIgual = contexto.array.max( porcentosHIP );

                //Retorna o resultado
                resolve(analiseAtual);

            }catch(e){
                throw e;
            }

        });
    },

    /*
    * Especifico pra tentar localizar imagens em uma foto
    * Compara varias imagens na imagem e diz quais deles apareceu na foto com % maior ou igual que porcentoAceito
    */
    findAll: async function(templatesProcurar, targets, porcentoAceito=28, porcentoDuvida=16){
        const contexto = this;

        return new Promise( async function(resolve) {
            /*Rostos que deram % maior ou igual que porcentoAceito*/
            const dadosBateram = [];
            const somentePorcentoBateram = [];
            const bateram = [];

            /*Rostos POSSIVEIS que NÂO SÂO CERTEZA, POREM QUE DERAM % maior ou igual que porcentoDuvida*/
            const dadosPodeSer = [];
            const somentePorcentosPodeSer = [];
            const podeSer = [];

            const somentePorcentosNaoBateu = [];

            //todos os resultados
            const pesquisasFeitas = [];

            //Para cada face
            const checagemLacoRepeticao = async function(templateAtualEstaBuscando, targetAtual) {

                const pesquisaImagem = await contexto.findImageInImage(templateAtualEstaBuscando, targetAtual, porcentoAceito);
                pesquisasFeitas.push(pesquisaImagem);

                //Se bateu
                if( pesquisaImagem.bateu ){

                    dadosBateram.push( {

                        face          : templateAtualEstaBuscando,
                        targetTestado : targetAtual,
                        resultados    : pesquisaImagem

                    } );

                    somentePorcentoBateram.push( pesquisaImagem.porcentoIgual );
                    bateram.push(templateAtualEstaBuscando);


                //Caso nao bater com exatidao
                }else{

                    somentePorcentosNaoBateu.push(pesquisaImagem.porcentoIgual);

                    //POREM, Se pelo menos foi aproximado
                    if( pesquisaImagem.porcentoIgual >= porcentoDuvida ){

                        dadosPodeSer.push( {

                            face           : templateAtualEstaBuscando,
                            targetTestado  : targetAtual,
                            resultados     : pesquisaImagem
                            
                        } );

                        somentePorcentosPodeSer.push( pesquisaImagem.porcentoIgual );
                        podeSer.push(templateAtualEstaBuscando);
                    }

                }

                return true;

            }
            
            targets.map( async function(targetTestando, indexTarget){

                //MAIS RAPIDO PODEM NAO PERMITE PEGAR OS DADOS EM ORDEM DE EXECUCAO, È EM PARALELO
                templatesProcurar.map( async function(templateAtualEstaBuscando, indexFace) {
                    const resUltimo = await checagemLacoRepeticao(templateAtualEstaBuscando, targetTestando);

                    console.log(resUltimo);

                    //Se for o ultimo, ele manda o resultado
                    if( indexFace == templatesProcurar.length-1 &&
                        indexTarget == targets.length-1

                    ){
        
                        resolve({

                            dadosBateram      : dadosBateram,
                            bateram           : bateram,
                            porcentosBateram  : somentePorcentoBateram,

                            dadosPodeSer      : dadosPodeSer,
                            podeSer           : podeSer,
                            porcentosPodeSer  : somentePorcentosPodeSer,

                            templatesUsados   : templatesProcurar,
                            targetsTestados   : targets,
                            todosResultados   : pesquisasFeitas,

                            //Todas as porcentagens que nao bateram em um array
                            porcentosNaoBateu : somentePorcentosNaoBateu

                        });
                    }

                });

            } )
            
        });
    },

    /*
    * Procura cada uma das imagens, e diz se pelo menos uma foi identificada
    * E tambem retorna se pelo menos uma foi classificada como possivel
    */
    verificarCorrespondencia: function(templatesProcurar, targets, porcentoAceito=28, porcentoDuvida=16){
        const contexto = this;

        return new Promise( async function(resolve) {

            const pesquisaImagems = await contexto.findAll(templatesProcurar, targets, porcentoAceito, porcentoDuvida, false);

            resolve({

                encontrada       : pesquisaImagems.bateram.length > 0,
                possibilidadeSer : pesquisaImagems.podeSer.length > 0,

                templatesUsados  : templatesProcurar,
                targetsTestados  : targets,
                resultados       : pesquisaImagems

            });
            

        });
    }
}

scanner.pagina = {
    /**
    * Cria um elemento personalizado na página
    * Permitindo obter o elemento HTML, e manipular ele usando métodos personalizados
    * @param {Object} classConfig 
    * @returns {scanner.pagina.Elemento}
    */
    Elemento: function(classConfig){
        const context = scanner.Base( classConfig );
        context.elemento = classConfig['elemento'];

        context.get = function(){
            return context;
        }

        context.getElemento = function(){
            return context.elemento;
        }

        context.ocultar = function(){
            context.elemento.style.visibility = 'hidden';
            context.elemento.style.display = 'none';
        }

        context.exibir = function(){
            context.elemento.style.visibility = 'visible';
            context.elemento.style.display = 'block';
        }

        context.estilizar = function(aplicarConfig){
            let keys = Object.keys(aplicarConfig);

            for( let i = 0 ; i < keys.length ; i++ )
            {
                context.elemento.style[ keys[i] ] = aplicarConfig[ keys[i] ];
            }

            return context;
        }

        context.aplicarAtributos = function(aplicarConfig){
            let keys = Object.keys(aplicarConfig);

            for( let i = 0 ; i < keys.length ; i++ )
            {
                context.elemento[ keys[i] ] = aplicarConfig[ keys[i] ];
            }

            return context;
        }

        return context;
    },

    /**
    * Fornece um objeto simples para armazenar o resultado da saida da camera
    * Permitindo facilmente obter informações
    * @param {Object} classConfig 
    * @returns {scanner.pagina.ResultadoCamera}
    */
    ResultadoCamera: function(classConfig){
        return new Promise(function(resolve){
            const context = scanner.Base( classConfig );

            context.canvas_resultado = classConfig['canvas_resultado'];
            context.base64 = classConfig['base64'] || context.canvas_resultado.toDataURL();
            
            scanner.utils.criarImagem( context.base64 )
            .then( function(imagemCriada){
                context.imagem = imagemCriada;

                context.getImagem = function(){
                    return context.imagem;
                }
        
                context.getBase64 = function(){
                    return context.base64;
                }
        
                context.getCanvas = function(){
                    return context.canvas_resultado;
                }

                resolve(context);
            } );
        });
    },

    /**
    * Fornece um objeto simples para armazenar os resultados de multipliplas saidas da camera
    * Permitindo facilmente obter informações, apenas pra isso
    * @param {Object} classConfig 
    * @returns {scanner.pagina.ResultadoCamera}
    */
    ResultadosCamera: async function(classConfig){
        const context = scanner.Base( classConfig );
        context.resultados = classConfig['resultados'] || [];

        context.incluir = function(resultado){
            context.resultados.push(resultado);
        }

        context.getImagens = function(){
            return context.resultados;
        }

        return context;
    },

    /**
    * Cria um elemento personalizado na página
    * Permitindo obter o elemento HTML, e manipular ele usando métodos personalizados
    * @param {String} elemento 
    * @param {String} id 
    * @returns {scanner.pagina.Elemento}
    */
    criarElementoHtml: function(elemento, id){
        let elementoCriado = document.createElement(elemento);
        elementoCriado.setAttribute('id', id);

        return scanner.pagina.Elemento({
            elemento: elementoCriado
        });
    } 
}

module.exports = window.scanner.Base;